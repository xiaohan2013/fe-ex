#开场语

大家下午好，很高兴能给大家做关于vue的分享。这次的训练中心和发现的管理后台的都是用vue来写的；完全采用vue以及vue的黄金搭配vuex,vue-router,vue-resouse

这次使用也是采用官方推荐的写法，单向数据流+单文件组件


#第一页

做过前端的人都知道，web本质是为了把数据（文本，多媒体）呈现出来。随着前端和后端的分离，前端业务的变得越来越复杂
前端不再是


# 第2页

vuejs的发展过程，其他从1到2的实际非常短，很快。作者也很厉害

从这个star的的个数，可以看出受关注度。从一个侧面反映了vue发展的比较好，也是比较成熟了的一个库



# 第3页

vuejs不是一个框架，这是作者自己说的。为什么这么说呢，因为vue并没有咱们开发中用到的路由啊，ajax啊，这些都需要我们把这些东西集成过来

vue核心功能是一个替代过去dom操作的过程



# 第4页

在使用vue进行复杂前端开发时，需要更多的关注路由、视图管理和数据持久化

因为在vue中每个视图的变化都是通过路由来指向



# 第5页





# 第6页

# 第7页
前边都是对vue的基本情况进行介绍，
接下来就是对vue在实际开发中怎样去解决前端复杂的数据变化
主要的想法就是：数据驱动和组件化

# 第9页
先来讲讲数据局驱动，顾名思义，数据驱动界面上的所有变化都是靠数据，数据中出现了变化来改变界面

通过用户的操作导致数据发送变化，同步到数据模型上去，然后又反映到视图。这样形成一个闭环

# 第10页

在过去，我们使用jquery或者原生的document.getElementById来获取Dom节点然后改变DOM。这里存在着两个主要的问题
1、这样获取dom节点，本身消耗是非常大的。
2、手动的更新和保持界面的数据，非常容易出现bug，尤其对那些页面上项目多的时候，而且各个数据项还有一些联动时，这样用直接拿，直接改dom的方式会造成代码很庞大，也很容易出错。

# 第11页
我们不去直接操作dom，那么如何呢？ 就是通过MVVM的模式来进行。
也就相当于在dom和model之间加一个中间层这就是viewmodel，这个viewmodel就是vue
通过vue去操作

这里的model,viewmodel,view，本质上是通过js中的一个方法来进行
Object.defineProperty,这个方法能够实现从数据到dom同步，从而实现双向绑定；
Object.defineProperty("obj", "key", {
    set(){

    },
    get(){

    }
})


# 第17-24页（组件化）
vue的另一个核心想法就是组件化。组件化是讲整个页面分成一个一个的小块，并且块与块之间是有一个层级关系。

那一个一个的绿色小立方体就是vue中所谓的vm，这里封装了所有业务逻辑。每个小立方个体彼此互不干扰彼此独立

一个完整的界面就可以形成一个有vue组件所组成的树。

vue是通过
// 定义一个vue的可复用的组件
component = vue.extend({
})
// 把这个组件注册到vue中
Vue.component('')

这时候就可以在vuejs模板使用这个组件了。

这时候，父组件和子组件之间如何通信，就是这个双向绑定的机制。
父组件——>子组件：动过双向绑定， $broadcast,$on
子组件——>父组件：通过事件，这个只能逐级向上传播，不能越级,$emit


# 第25页（实现细节）
1、vue的底层实现细节就是，ES5的Object.defineProperty(),可以通过在一个对象的获取和设置时能够
修改去触发get,set方法，这时候能在这些方法里边做些其他事情


# 第29页
低侵入性：用vue但是不强制使用
这里一般的最佳组合就是这个，基本上我们这次的后台完全依靠这些就解决了我们的需求
vue：就是讲页面分成一个一个的组件，
vuex: 作为数据管理，让数据单向流动。flux
vue-router: 提供了路由，就是组件的切换作用
vue-resource: 网络的
element-ui: 这个是UI


作者也是鼓励模块化，组件化。将界面划分为一个一个独立的小模块，便于维护，也能减少重复的代码

在vue2.0里边，由于工具链的完善，写vue组件更加方便，将组件只需写在vue文件中就行，vue = 模板 + style + components























