// 模块

// "外部模块"=> "模块"
// "内部模块"=> "命名空间"


// 从ECMAScript 2015开始，JavaScript引入了模块的概念。TypeScript也沿用这个概念。

// 模块在其自身的作用域里执行，而不是在全局作用域里；
// 这意味着定义在一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确地使用export形式之一导出它们。 
// 相反，如果想使用其它模块导出的变量，函数，类，接口等的时候，你必须要导入它们，可以使用 import形式之一。


// 模块是自声明的；两个模块之间的关系是通过在文件级别上使用imports和exports建立的。

// 每个模块都可以有一个default导出。 默认导出使用 default关键字标记；并且一个模块只能够有一个default导出。 需要使用一种特殊的导入形式来导入 default导出。

// export = 和 import = require()

// export =语法定义一个模块的导出对象。 它可以是类，接口，命名空间，函数或枚举。

// 若要导入一个使用了export =的模块时，必须使用TypeScript提供的特定语法import module = require("module")。

// 生成模块代码


// 有时候，你只想在某种条件下才加载某个模块。 在TypeScript里，使用下面的方式来实现它和其它的高级加载场景，我们可以直接调用模块加载器并且可以保证类型完全。


// 可选的模块加载和其它高级加载场景

// 编译器会检测是否每个模块都会在生成的JavaScript中用到。 
// 如果一个模块标识符只在类型注解部分使用，并且完全没有在表达式中使用时，就不会生成 require这个模块的代码。 
// 省略掉没有用到的引用对性能提升是很有益的，并同时提供了选择性加载模块的能力。

// 为了确保类型安全性，我们可以使用typeof关键字。 typeof关键字，当在表示类型的地方使用时，会得出一个类型值，这里就表示模块的类型。

declare function require( moduleName: string): any;


// 使用其它的JavaScript库
// 要想描述非TypeScript编写的类库的类型，我们需要声明类库所暴露出的API。
// 我们叫它声明因为它不是“外部程序”的具体实现。 它们通常是在 .d.ts文件里定义的。 如果你熟悉C/C++，你可以把它们当做 .h文件。 让我们看一些例子。

// 外部模块
// 外部模块简写
// 模块声明通配符
// UMD模块

// 模块里不要使用命名空间


